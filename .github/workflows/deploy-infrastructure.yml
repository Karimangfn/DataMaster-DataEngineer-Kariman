run-name: Deploy Cloud Infrastructure 
name: Deploy Cloud Infrastructure

permissions: write-all

on:
  workflow_dispatch:

jobs:    
  check-gh-pat:
    name: ðŸ” Check GH_PAT_TOKEN and permissions
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ”Ž Check if GH_PAT_TOKEN is present
        run: |
          if [ -z "${{ secrets.GH_PAT_TOKEN }}" ]; then
            echo "Error: the GH_PAT_TOKEN secret is not defined in the repository."
            exit 1
          else
            echo "Secret GH_PAT_TOKEN found."
          fi

      - name: ðŸ”— Test token permission via API (checks if it can access the current repository)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          echo "Testing API access with GH_PAT_TOKEN..."
          HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/$REPO)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: GH_PAT_TOKEN does not have permission to access the repository $REPO."
            echo "API response:"
            cat response.json
            exit 1
          else
            echo "Valid token with access to the repository."
          fi

      - name: ðŸ§ª Test if token can access secrets API
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          echo "Checking if the token can access the secrets API..."
          HTTP_CODE=$(curl -s -o secrets_response.json -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/$REPO/actions/secrets)
  
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: the GH_PAT_TOKEN token does not have permission to access the secrets API in the repository $REPO."
            echo "API response:"
            cat secrets_response.json
            exit 1
          else
            echo "Token has access to the secrets API. It can probably create secrets as well."
          fi

  check-azure-role-assignments:
    name: ðŸ” Check Azure Role Assignments
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: ðŸ”Ž Check Role Assignments
        run: |
          set -e
          
          CLIENT_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
          SUBSCRIPTION_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}"
          SCOPE="/subscriptions/$SUBSCRIPTION_ID"
          
          echo "ðŸ” Checking permissions for Service Principal: $CLIENT_ID in scope $SCOPE..."
          ROLES=$(az role assignment list --assignee "$CLIENT_ID" --scope "$SCOPE" --query "[].roleDefinitionName" -o tsv)
          
          echo "$ROLES" | grep -q "Contributor" || \
               { echo "âŒ Service Principal does not have the 'Contributor' role"; exit 1; }
          
          echo "$ROLES" | grep -q "User Access Administrator" || \
               { echo "âŒ Service Principal does not have the 'User Access Administrator' role"; exit 1; }
          
          echo "âœ… Client ID has the 'Contributor' and 'User Access Administrator' roles."

  check-azuread-group-permissions:
    name: ðŸ” Check Azure AD Graph Permissions
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ”Ž Validate SPN Graph Permissions
        run: |
          set -e

          CLIENT_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
          echo "ðŸ” Debug: CLIENT_ID=$CLIENT_ID"

          echo "ðŸ” Validating SPN has Application.Read.All permission..."
          if ! az ad app permission list --id "$CLIENT_ID" -o tsv >/dev/null 2>&1; then
            echo "âŒ Service Principal does NOT have Application.Read.All permission."
            exit 1
          fi
          echo "âœ… SPN has Application.Read.All permission."

          echo "ðŸ” Checking Group.ReadWrite.All permission..."
          PERMS=$(az ad app permission list --id "$CLIENT_ID" --query "[?resourceAppId=='00000003-0000-0000-c000-000000000000'].resourceAccess[].id" -o tsv)
          echo "ðŸ” Debug: PERMISSIONS IDs retrieved:"
          echo "$PERMS"

          GROUP_RW_ID=$(az ad sp show --id 00000003-0000-0000-c000-000000000000 --query "appRoles[?value=='Group.ReadWrite.All'].id" -o tsv)
          echo "ðŸ” Debug: Group.ReadWrite.All ID=$GROUP_RW_ID"

          if echo "$PERMS" | grep -iq "$GROUP_RW_ID"; then
              echo "âœ… Service Principal has Group.ReadWrite.All permission granted with admin consent."
          else
              echo "âŒ Service Principal does NOT have Group.ReadWrite.All permission granted with admin consent."
              exit 1
          fi
          
  resource-group:
    name: ðŸ—ï¸ Creating Resource Group
    runs-on: ubuntu-latest
    needs: [check-azure-role-assignments, check-azuread-group-permissions, check-gh-pat]
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3

      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate
      
      - name: ðŸš€ Apply Resource Group via Terraform
        run: | 
          terraform apply -auto-approve \
            -target=module.resource_group.azurerm_resource_group.rg \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: ðŸ“¦ Get Resource Group Name
        id: tfoutput_rg
        run: |
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          echo "Detected Resource Group from Terraform: $RESOURCE_GROUP_NAME"
          echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP_NAME" >> $GITHUB_ENV

      - name: ðŸ§¾ Set RESOURCE_GROUP_NAME secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          RESOURCE_GROUP_NAME: ${{ env.RESOURCE_GROUP_NAME }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set RESOURCE_GROUP --repo $REPO --body "$RESOURCE_GROUP_NAME"

  acr:
    name: ðŸ³ Creating Container Registry (ACR)
    runs-on: ubuntu-latest
    needs: resource-group
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
      
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply ACR via Terraform
        run: |
          terraform apply -auto-approve \
            -target=module.acr.azurerm_container_registry.acr \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: ðŸ“¦ Get Container Registry Name
        id: tfoutput_acr
        run: |
          CONTAINER_REGISTRY_NAME=$(terraform output -raw container_registry_name)
          echo "CONTAINER_REGISTRY_NAME=$CONTAINER_REGISTRY_NAME" >> $GITHUB_ENV

      - name: ðŸ§¾ Set CONTAINER_REGISTRY_NAME secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          CONTAINER_REGISTRY_NAME: ${{ env.CONTAINER_REGISTRY_NAME }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set ACR_NAME --repo $REPO --body "$CONTAINER_REGISTRY_NAME"
          
  aks:
    name: â˜¸ï¸ Creating AKS Cluster
    runs-on: ubuntu-latest
    needs: acr
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
      
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply AKS Cluster via Terraform
        run: |
          terraform apply -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -target=module.aks.azurerm_kubernetes_cluster.aks \
            -target=module.aks.azurerm_role_assignment.aks_acr_pull \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ§¹ Clean Up Network Watcher
        run: |
          terraform destroy -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: â˜ï¸ Get Azure Kubernetes Service Name
        id: tfoutput_aks
        run: |
          KUBERNETES_SERVICE=$(terraform output -raw kubernetes_cluster_name)
          echo "KUBERNETES_SERVICE=$KUBERNETES_SERVICE" >> $GITHUB_ENV

      - name: ðŸ§¾ Set KUBERNETES_SERVICE secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          KUBERNETES_SERVICE: ${{ env.KUBERNETES_SERVICE }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set AKS_NAME --repo $REPO --body "$KUBERNETES_SERVICE"
 
  storage-account:
    name: ðŸ’¾ Creating Storage Account
    runs-on: ubuntu-latest
    needs: aks
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
      
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply Storage Account via Terraform
        run: |
          terraform apply -auto-approve \
            -target=module.storage.azurerm_storage_account.lake \
            -target=module.storage.azurerm_role_assignment.spn_storage_blob_contributor \
            -var="subscription_id=$(az account show --query id -o tsv)" \
            -var="client_id=${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: ðŸ“¦ Get Storage Account Name
        id: tfoutput_storage
        run: |
          STORAGE_ACCOUNT_NAME=$(terraform output -raw storage_account_name)
          echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
  
      - name: ðŸ§¾ Set STORAGE_ACCOUNT secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          STORAGE_ACCOUNT_NAME: ${{ env.STORAGE_ACCOUNT_NAME }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set STORAGE_ACCOUNT --repo $REPO --body "$STORAGE_ACCOUNT_NAME"

  storage-containers:
    name: ðŸ“ Creating Storage Containers
    runs-on: ubuntu-latest
    needs: storage-account
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
      
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply Storage Containers via Terraform
        run: |
          terraform apply -auto-approve \
            -target=module.storage.azurerm_storage_container.raw \
            -target=module.storage.azurerm_storage_container.bronze \
            -target=module.storage.azurerm_storage_container.silver \
            -target=module.storage.azurerm_storage_container.gold \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

  databricks:
    name: ðŸ§ª Creating Databricks Workspace
    runs-on: ubuntu-latest
    needs: storage-containers
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
      
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: ðŸ“¦ Get Terraform Outputs
        id: tfoutput_rg
        run: |
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          STORAGE_ACCOUNT_NAME=$(terraform output -raw storage_account_name)
          echo "âœ… Detected Resource Group from Terraform: $RESOURCE_GROUP_NAME"
          echo "âœ… Detected Storage Account from Terraform: $STORAGE_ACCOUNT_NAME"
          echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP_NAME" >> $GITHUB_ENV
          echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
      
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply Databricks Workspace and Access Connector
        run: |
          terraform apply -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -target=module.databricks.azurerm_databricks_workspace.dbw \
            -target=module.databricks.azurerm_databricks_access_connector.connect-unity \
            -var="subscription_id=$(az account show --query id -o tsv)"
  
      - name: ðŸ§¹ Clean Up Network Watcher
        run: |
          terraform destroy -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ”Ž Get workspace URL and AAD token
        id: get-databricks-info
        run: |
          tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
          post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=2ff814a6-3304-4ab8-85cb-cd0e6f879c1d/.default"
          TOKEN=$(curl -X POST -H "Content-Type: application/x-www-form-urlencoded" $uri --data "$post_data" | jq -r '.access_token')
          WORKSPACE_URL="https://$(terraform output -raw databricks_workspace_url)"
          echo "WORKSPACE_URL=$WORKSPACE_URL" >> $GITHUB_ENV
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "workspace_url=$WORKSPACE_URL" >> $GITHUB_OUTPUT
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "::add-mask::$TOKEN"

      - name: ðŸ”§ Create Git Credential on Databricks
        run: |
          curl -X POST "$WORKSPACE_URL/api/2.0/git-credentials" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "git_provider": "gitHub",
              "git_username": "x-token-auth",
              "personal_access_token": "'"${{ secrets.GH_PAT_TOKEN }}"'"
            }'
      
      - name: ðŸ§¹ Clean up old Databricks resources
        run: |
          LOCATIONS=("bronze_external" "silver_external" "gold_external")
          for loc in "${LOCATIONS[@]}"; do
            echo "ðŸ§¹ Checking if external location $loc exists..."
            LOC_URL="$WORKSPACE_URL/api/2.1/unity-catalog/external-locations/$loc"
            if curl -s -H "Authorization: Bearer $TOKEN" "$LOC_URL" | grep -q '"name"'; then
              echo "ðŸ—‘ï¸ Deleting existing external location $loc"
              curl -X DELETE -H "Authorization: Bearer $TOKEN" "$LOC_URL"
            fi
          done
      
          CRED_NAME="connector_cred"
          CRED_URL="$WORKSPACE_URL/api/2.1/unity-catalog/storage-credentials/$CRED_NAME?force=true"
          echo "ðŸ§¹ Checking for existing credential '$CRED_NAME'..."
          if curl -s -H "Authorization: Bearer $TOKEN" \
                "$WORKSPACE_URL/api/2.1/unity-catalog/storage-credentials/$CRED_NAME" | grep -q '"name"'; then
            echo "ðŸ—‘ï¸ Deleting existing credential '$CRED_NAME' with force=true"
            curl -X DELETE -H "Authorization: Bearer $TOKEN" "$CRED_URL"
            sleep 5
          else
            echo "âœ… No existing credential found"
          fi

      - name: ðŸš€ Apply Databricks Storage Credential
        run: |
          terraform apply -auto-approve \
            -target=module.databricks.databricks_storage_credential.credential \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ” Capture Access Connector Info (from terraform outputs)
        id: connector-info
        run: |
          set -euo pipefail
      
          ACCESS_CONNECTOR_ID=$(terraform output -raw databricks_access_connector_id 2>/dev/null || true)
          PRINCIPAL_ID=$(terraform output -raw databricks_access_connector_principal_id 2>/dev/null || true)
      
          if [ -z "$ACCESS_CONNECTOR_ID" ] || [ -z "$PRINCIPAL_ID" ]; then
            echo "âŒ Terraform outputs for access connector are missing. Make sure the connector was applied."
            echo "ACCESS_CONNECTOR_ID=$ACCESS_CONNECTOR_ID" >> $GITHUB_ENV
            echo "PRINCIPAL_ID=$PRINCIPAL_ID" >> $GITHUB_ENV
            exit 1
          fi
      
          echo "âœ… Access Connector ID: $ACCESS_CONNECTOR_ID"
          echo "âœ… Principal ID: $PRINCIPAL_ID"
      
          echo "ACCESS_CONNECTOR_ID=$ACCESS_CONNECTOR_ID" >> $GITHUB_ENV
          echo "PRINCIPAL_ID=$PRINCIPAL_ID" >> $GITHUB_ENV
  
      - name: ðŸ—ï¸ Assign Blob Contributor Role to Storage Account
        run: |
          set -euo pipefail
      
          STORAGE_ACCOUNT="${{ env.STORAGE_ACCOUNT_NAME }}"
          PRINCIPAL_ID="${{ env.PRINCIPAL_ID }}"
          SCOPE=$(az storage account show --name "$STORAGE_ACCOUNT" --query id -o tsv)
      
          if [ -z "$SCOPE" ]; then
            echo "âŒ Could not find storage account $STORAGE_ACCOUNT"
            exit 1
          fi
      
          echo "Assigning 'Storage Blob Data Contributor' role..."
          az role assignment create \
            --assignee "$PRINCIPAL_ID" \
            --role "Storage Blob Data Contributor" \
            --scope "$SCOPE"
          echo "âœ… Role assigned"

      - name: ðŸ› ï¸ Set ADLS Gen2 ACLs for Databricks Managed Identity
        run: |
          ACCOUNT="${{ env.STORAGE_ACCOUNT_NAME }}"
          PRINCIPAL="${{ env.PRINCIPAL_ID }}"
      
          for container in bronze silver gold; do
            echo "ðŸ”‘ Setting ACL on $container"
            az storage fs access set \
              --account-name "$ACCOUNT" \
              --file-system "$container" \
              --path / \
              --acl "user:${PRINCIPAL}:rwx"
            echo "âœ… ACL set on $container"
          done

      - name: ðŸš€ Create Databricks External Locations
        run: |
          terraform apply -auto-approve \
            -target=module.databricks.databricks_external_location.bronze \
            -target=module.databricks.databricks_external_location.silver \
            -target=module.databricks.databricks_external_location.gold \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸš€ Create Databricks Schema
        run: |   
          terraform apply -auto-approve \
            -target=module.databricks.databricks_schema.data_processing_db \
            -var="subscription_id=$(az account show --query id -o tsv)"
        
      - name: ðŸš€ Create Databricks Job
        run: |
          terraform apply -auto-approve \
            -refresh=false \
            -target=module.databricks.databricks_job.data_process \
            -var="client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" \
            -var="client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" \
            -var="tenant_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" \
            -var="subscription_id=$(az account show --query id -o tsv)" \
            -var="git_repo_branch=${{ github.ref_name }}" \
            -var="git_repo_url=https://github.com/${{ github.repository }}.git" \
            -var="enable_databricks=true"

      - name: ðŸ‘¥ Create data_engineers group
        run: |
          echo "ðŸ“¡ Creating group data_engineers..."
          RESPONSE=$(
            curl -i -w "\nStatus: %{http_code}\n" -X POST \
              "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/scim+json" \
              -d '{"displayName": "data_engineers"}'
          )
          echo "ðŸ” API Response:"
          echo "$RESPONSE"
  
      - name: ðŸ‘¥ Create data_scientists group
        run: |
          echo "ðŸ“¡ Creating group data_scientists..."
          RESPONSE=$(
            curl -i -w "\nStatus: %{http_code}\n" -X POST \
              "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/scim+json" \
              -d '{"displayName": "data_scientists"}'
          )
          echo "ðŸ” API Response:"
          echo "$RESPONSE"
  
      - name: ðŸ‘¥ Create data_analysts group
        run: |
          echo "ðŸ“¡ Creating group data_analysts..."
          RESPONSE=$(
            curl -i -w "\nStatus: %{http_code}\n" -X POST \
              "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/scim+json" \
              -d '{"displayName": "data_analysts"}'
          )
          echo "ðŸ” API Response:"
          echo "$RESPONSE"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

  azure-groups-and-access:
    name: ðŸ”‘ Create Azure Groups and Assign Roles
    runs-on: ubuntu-latest
    needs: databricks
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
  
      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
  
      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
  
      - name: ðŸ§° Initialize Terraform
        run: terraform init

      - name: âœ… Validate Terraform Configuration
        run: terraform validate

      - name: ðŸš€ Apply Azure AD Groups and Role Assignments
        run: |
          terraform apply -auto-approve \
            -target=module.access.azuread_group.data_engineers \
            -target=module.access.azuread_group.data_analysts \
            -target=module.access.azuread_group.data_scientists \
            -target=module.access.azurerm_role_assignment.raw_access \
            -target=module.access.azurerm_role_assignment.bronze_access \
            -target=module.access.azurerm_role_assignment.silver_access \
            -target=module.access.azurerm_role_assignment.gold_access \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: ðŸ“¤ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

  generate-summary:
    name: ðŸ“ Generate Creation and Update Summary
    runs-on: ubuntu-latest
    if: always() && !cancelled()
    needs:
      - resource-group
      - acr
      - aks
      - storage-account
      - storage-containers
      - databricks
      - azure-groups-and-access
    steps:
      - name: ðŸ§© Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ” Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ“¥ Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure

      - name: ðŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: ðŸ“ Generate Summary Table
        run: |
          set -euo pipefail

          echo "## ðŸš€ Terraform Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Resource Name | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|----------------|--------|" >> $GITHUB_STEP_SUMMARY

          cd infrastructure
          terraform init -input=false -no-color >/dev/null

          RG_NAME=$(terraform output -raw resource_group_name 2>/dev/null || echo "N/A")
          ACR_NAME=$(terraform output -raw container_registry_name 2>/dev/null || echo "N/A")
          AKS_NAME=$(terraform output -raw kubernetes_service_name 2>/dev/null || echo "N/A")
          STORAGE_ACCOUNT=$(terraform output -raw storage_account_name 2>/dev/null || echo "N/A")
          DB_WORKSPACE=$(terraform output -raw databricks_workspace_url 2>/dev/null || echo "N/A")

          declare -A JOBS
          declare -A RESOURCES

          JOBS["ðŸ—ï¸ Resource Group"]="${{ needs.resource-group.result }}"
          RESOURCES["ðŸ—ï¸ Resource Group"]="$RG_NAME"

          JOBS["ðŸ³ Azure Container Registry (ACR)"]="${{ needs.acr.result }}"
          RESOURCES["ðŸ³ Azure Container Registry (ACR)"]="$ACR_NAME"

          JOBS["â˜¸ï¸ Azure Kubernetes Service (AKS)"]="${{ needs.aks.result }}"
          RESOURCES["â˜¸ï¸ Azure Kubernetes Service (AKS)"]="$AKS_NAME"

          JOBS["ðŸ’¾ Storage Account"]="${{ needs.storage-account.result }}"
          RESOURCES["ðŸ’¾ Storage Account"]="$STORAGE_ACCOUNT"

          JOBS["ðŸ“ Storage Containers"]="${{ needs.storage-containers.result }}"
          RESOURCES["ðŸ“ Storage Containers"]="raw, bronze, silver, gold"

          JOBS["ðŸ§ª Databricks Workspace"]="${{ needs.databricks.result }}"
          RESOURCES["ðŸ§ª Databricks Workspace"]="$DB_WORKSPACE"

          JOBS["ðŸ”‘ Azure AD Groups & Access"]="${{ needs.azure-groups-and-access.result }}"
          RESOURCES["ðŸ”‘ Azure AD Groups & Access"]="data_engineers, data_scientists, data_analysts"

          STOP=false
          for STAGE in "ðŸ—ï¸ Resource Group" \
                       "ðŸ³ Azure Container Registry (ACR)" \
                       "â˜¸ï¸ Azure Kubernetes Service (AKS)" \
                       "ðŸ’¾ Storage Account" \
                       "ðŸ“ Storage Containers" \
                       "ðŸ§ª Databricks Workspace" \
                       "ðŸ”‘ Azure AD Groups & Access"; do

            if [ "$STOP" = true ]; then
              break
            fi

            RESULT="${JOBS[$STAGE]}"
            NAME="${RESOURCES[$STAGE]}"

            if [ "$RESULT" = "success" ]; then
              STATUS="âœ…"
            else
              STATUS="âŒ"
              STOP=true
            fi

            echo "| $STAGE | $NAME | $STATUS |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$STOP" = true ]; then
            echo "âŒ **Pipeline stopped due to failure in one or more stages.**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… **All Terraform-managed resources were successfully created and configured.**" >> $GITHUB_STEP_SUMMARY
          fi
