run-name: Deploy Cloud Infrastructure 
name: Deploy Cloud Infrastructure

permissions: write-all

on:
  workflow_dispatch:

jobs:    
  debug-databricks-groups:
    name: üêû Debug Databricks Groups
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üîê Generate AAD Token
        id: get-token
        run: |
          set -e
          tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')

          uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
          post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=https://graph.microsoft.com/.default"

          TOKEN=$(curl -s -X POST -H "Content-Type: application/x-www-form-urlencoded" \
                  -d "$post_data" $uri | jq -r '.access_token')

          if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
            echo "‚ùå Failed to obtain token"
            exit 1
          fi

          echo "::add-mask::$TOKEN"
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "‚úÖ Token obtained successfully"

      - name: üß™ Create Test Group in Microsoft Entra ID
        run: |
          set -e
          echo "üì° Creating test group via Microsoft Graph API..."
          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\n" \
            -X POST "https://graph.microsoft.com/v1.0/groups" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "displayName": "ci_test_group",
              "mailEnabled": false,
              "mailNickname": "ci_test_group",
              "securityEnabled": true
            }')

          echo "$RESPONSE"

          STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS" | cut -d':' -f2)
          if [ "$STATUS" != "201" ]; then
            echo "‚ùå Failed to create group (HTTP $STATUS)"
            exit 1
          fi

          echo "‚úÖ Group created successfully!"

      # - name: üîé Get workspace URL and AAD token
      #   id: get-databricks-info
      #   run: |
      #     tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
      #     client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
      #     client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
      #     uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
      #     post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=2ff814a6-3304-4ab8-85cb-cd0e6f879c1d/.default"
      #     TOKEN=$(curl -X POST -H "Content-Type: application/x-www-form-urlencoded" $uri --data "$post_data" | jq -r '.access_token')
      #     WORKSPACE_URL="https://adb-3536511084591671.11.azuredatabricks.net"
      #     echo "WORKSPACE_URL=$WORKSPACE_URL" >> $GITHUB_ENV
      #     echo "TOKEN=$TOKEN" >> $GITHUB_ENV
      #     echo "workspace_url=$WORKSPACE_URL" >> $GITHUB_OUTPUT
      #     echo "token=$TOKEN" >> $GITHUB_OUTPUT
      #     echo "::add-mask::$TOKEN"

      # - name: üë• Create data_engineers group
      #   run: |
      #     echo "üì° Creating group data_engineers..."
      #     curl -i -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_engineers"}'

      # - name: üë• Create data_scientists group
      #   run: |
      #     echo "üì° Creating group data_scientists..."
      #     curl -i -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_scientists"}'

      # - name: üë• Create data_analysts group
      #   run: |
      #     echo "üì° Creating group data_analysts..."
      #     curl -i -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_analysts"}'

  # check-gh-pat:
  #   name: üîê Check GH_PAT_TOKEN and permissions
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: üîé Check if GH_PAT_TOKEN is present
  #       run: |
  #         if [ -z "${{ secrets.GH_PAT_TOKEN }}" ]; then
  #           echo "Error: the GH_PAT_TOKEN secret is not defined in the repository."
  #           exit 1
  #         else
  #           echo "Secret GH_PAT_TOKEN found."
  #         fi

  #     - name: üîó Test token permission via API (checks if it can access the current repository)
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         echo "Testing API access with GH_PAT_TOKEN..."
  #         HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" \
  #           -H "Authorization: token $GH_TOKEN" \
  #           -H "Accept: application/vnd.github+json" \
  #           https://api.github.com/repos/$REPO)

  #         if [ "$HTTP_CODE" != "200" ]; then
  #           echo "Error: GH_PAT_TOKEN does not have permission to access the repository $REPO."
  #           echo "API response:"
  #           cat response.json
  #           exit 1
  #         else
  #           echo "Valid token with access to the repository."
  #         fi

  #     - name: üß™ Test if token can access secrets API
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         echo "Checking if the token can access the secrets API..."
  #         HTTP_CODE=$(curl -s -o secrets_response.json -w "%{http_code}" \
  #           -H "Authorization: token $GH_TOKEN" \
  #           -H "Accept: application/vnd.github+json" \
  #           https://api.github.com/repos/$REPO/actions/secrets)
  
  #         if [ "$HTTP_CODE" != "200" ]; then
  #           echo "Error: the GH_PAT_TOKEN token does not have permission to access the secrets API in the repository $REPO."
  #           echo "API response:"
  #           cat secrets_response.json
  #           exit 1
  #         else
  #           echo "Token has access to the secrets API. It can probably create secrets as well."
  #         fi

  # check-azure-role-assignments:
  #   name: üìú Check Azure Role Assignments
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üîé Check Role Assignments
  #       run: |
  #         set -e

  #         CLIENT_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
  #         SUBSCRIPTION_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}"
  #         SCOPE="/subscriptions/$SUBSCRIPTION_ID"

  #         echo "üîç Checking permissions for Service Principal: $CLIENT_ID in scope $SCOPE..."

  #         ROLES=$(az role assignment list --assignee "$CLIENT_ID" --scope "$SCOPE" --query "[].roleDefinitionName" -o tsv)

  #         echo "$ROLES" | grep -q "Contributor" || {
  #           echo "‚ùå Service Principal does not have the 'Contributor' role"
  #           exit 1
  #         }

  #         echo "$ROLES" | grep -q "User Access Administrator" || {
  #           echo "‚ùå Service Principal does not have the 'User Access Administrator' role"
  #           exit 1
  #         }

  #         echo "‚úÖ Client ID has the 'Contributor' and 'User Access Administrator' roles."
          
  # resource-group:
  #   name: üèóÔ∏è Creating Resource Group
  #   runs-on: ubuntu-latest
  #   needs: [check-azure-role-assignments, check-gh-pat]
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3

  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7

  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.resource_group.azurerm_resource_group.rg \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - run: terraform validate
      
  #     - run: | 
  #         terraform apply -auto-approve \
  #           -target=module.resource_group.azurerm_resource_group.rg \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: üì¶ Get Resource Group Name
  #       id: tfoutput_rg
  #       run: |
  #         RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
  #         echo "Detected Resource Group from Terraform: $RESOURCE_GROUP_NAME"
  #         echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP_NAME" >> $GITHUB_ENV

  #     - name: üßæ Set RESOURCE_GROUP_NAME secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         RESOURCE_GROUP_NAME: ${{ env.RESOURCE_GROUP_NAME }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set RESOURCE_GROUP --repo $REPO --body "$RESOURCE_GROUP_NAME"

  # acr:
  #   name: üê≥ Creating Container Registry (ACR)
  #   runs-on: ubuntu-latest
  #   needs: resource-group
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.acr.azurerm_container_registry.acr \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true

  #     - run: terraform validate
  
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.acr.azurerm_container_registry.acr \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: üì¶ Get Container Registry Name
  #       id: tfoutput_acr
  #       run: |
  #         CONTAINER_REGISTRY_NAME=$(terraform output -raw container_registry_name)
  #         echo "CONTAINER_REGISTRY_NAME=$CONTAINER_REGISTRY_NAME" >> $GITHUB_ENV

  #     - name: üßæ Set CONTAINER_REGISTRY_NAME secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         CONTAINER_REGISTRY_NAME: ${{ env.CONTAINER_REGISTRY_NAME }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set ACR_NAME --repo $REPO --body "$CONTAINER_REGISTRY_NAME"
          
  # aks:
  #   name: ‚ò∏Ô∏è Creating AKS Cluster
  #   runs-on: ubuntu-latest
  #   needs: acr
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.aks.azurerm_kubernetes_cluster.aks \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true
  
  #     - run: terraform validate
  
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -target=module.aks.azurerm_kubernetes_cluster.aks \
  #           -target=module.aks.azurerm_role_assignment.aks_acr_pull \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #         terraform destroy -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: ‚òÅÔ∏è Get Azure Kubernetes Service Name
  #       id: tfoutput_aks
  #       run: |
  #         KUBERNETES_SERVICE=$(terraform output -raw kubernetes_cluster_name)
  #         echo "KUBERNETES_SERVICE=$KUBERNETES_SERVICE" >> $GITHUB_ENV

  #     - name: üßæ Set KUBERNETES_SERVICE secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         KUBERNETES_SERVICE: ${{ env.KUBERNETES_SERVICE }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set AKS_NAME --repo $REPO --body "$KUBERNETES_SERVICE"
 
  # storage-account:
  #   name: üíæ Creating Storage Account
  #   runs-on: ubuntu-latest
  #   needs: resource-group
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.storage.azurerm_storage_account.lake \
  #          -target=module.storage.azurerm_role_assignment.spn_storage_blob_contributor \
  #          -var="subscription_id=$(az account show --query id -o tsv)" \
  #          -var="client_id=${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true
      
  #     - run: terraform validate
      
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.storage.azurerm_storage_account.lake \
  #           -target=module.storage.azurerm_role_assignment.spn_storage_blob_contributor \
  #           -var="subscription_id=$(az account show --query id -o tsv)" \
  #           -var="client_id=${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: üì¶ Get Storage Account Name
  #       id: tfoutput_storage
  #       run: |
  #         STORAGE_ACCOUNT_NAME=$(terraform output -raw storage_account_name)
  #         echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
  
  #     - name: üßæ Set STORAGE_ACCOUNT secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         STORAGE_ACCOUNT_NAME: ${{ env.STORAGE_ACCOUNT_NAME }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set STORAGE_ACCOUNT --repo $REPO --body "$STORAGE_ACCOUNT_NAME"

  # storage-containers:
  #   name: üìÅ Creating Storage Containers
  #   runs-on: ubuntu-latest
  #   needs: storage-account
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #           -target=module.storage.azurerm_storage_container.raw \
  #           -target=module.storage.azurerm_storage_container.bronze \
  #           -target=module.storage.azurerm_storage_container.silver \
  #           -target=module.storage.azurerm_storage_container.gold \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true
      
  #     - run: terraform validate
      
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.storage.azurerm_storage_container.raw \
  #           -target=module.storage.azurerm_storage_container.bronze \
  #           -target=module.storage.azurerm_storage_container.silver \
  #           -target=module.storage.azurerm_storage_container.gold \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  # databricks:
  #   name: üß™ Creating Databricks Workspace
  #   runs-on: ubuntu-latest
  #   needs: storage-containers
  #   outputs:
  #     workspace_url: ${{ steps.get-databricks-info.outputs.workspace_url }}
  #     token: ${{ steps.get-databricks-info.outputs.token }}
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7

  #     - name: üì¶ Get Terraform Outputs
  #       id: tfoutput_rg
  #       run: |
  #         RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
  #         STORAGE_ACCOUNT_NAME=$(terraform output -raw storage_account_name)
  #         echo "‚úÖ Detected Resource Group from Terraform: $RESOURCE_GROUP_NAME"
  #         echo "‚úÖ Detected Storage Account from Terraform: $STORAGE_ACCOUNT_NAME"
  #         echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP_NAME" >> $GITHUB_ENV
  #         echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #            -target=module.databricks.azurerm_databricks_workspace.dbw \
  #            -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true
      
  #     - run: terraform validate
      
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -target=module.databricks.azurerm_databricks_workspace.dbw \
  #           -target=module.databricks.azurerm_databricks_access_connector.connect-unity \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #         terraform destroy -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üîé Get workspace URL and AAD token
  #       id: get-databricks-info
  #       run: |
  #         tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
  #         client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
  #         client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
  #         uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
  #         post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=2ff814a6-3304-4ab8-85cb-cd0e6f879c1d/.default"
  #         TOKEN=$(curl -X POST -H "Content-Type: application/x-www-form-urlencoded" $uri --data "$post_data" | jq -r '.access_token')
  #         WORKSPACE_URL="https://$(terraform output -raw databricks_workspace_url)"
  #         echo "WORKSPACE_URL=$WORKSPACE_URL" >> $GITHUB_ENV
  #         echo "TOKEN=$TOKEN" >> $GITHUB_ENV
  #         echo "workspace_url=$WORKSPACE_URL" >> $GITHUB_OUTPUT
  #         echo "token=$TOKEN" >> $GITHUB_OUTPUT
  #         echo "::add-mask::$TOKEN"

  #     - name: üîß Create Git Credential on Databricks
  #       run: |
  #         curl -X POST "$WORKSPACE_URL/api/2.0/git-credentials" \
  #           -H "Authorization: Bearer $TOKEN" \
  #           -H "Content-Type: application/json" \
  #           -d '{
  #             "git_provider": "gitHub",
  #             "git_username": "x-token-auth",
  #             "personal_access_token": "'"${{ secrets.GH_PAT_TOKEN }}"'"
  #           }'
      
  #     - name: üßπ Clean up old external locations
  #       run: |
  #         for loc in bronze_external silver_external gold_external; do
  #           echo "üßπ Checking if $loc exists..."
  #           if curl -s -H "Authorization: Bearer $TOKEN" "$WORKSPACE_URL/api/2.1/unity-catalog/external-locations/$loc" | grep -q '"name"'; then
  #             echo "üóëÔ∏è Deleting existing $loc"
  #             curl -X DELETE -H "Authorization: Bearer $TOKEN" "$WORKSPACE_URL/api/2.1/unity-catalog/external-locations/$loc"
  #           fi
  #         done
      
  #     - name: üßπ Delete old Databricks credentials if they exist (force delete)
  #       run: |
  #         echo "üßπ Checking for existing credential 'connector_cred'..."
  #         if curl -s -H "Authorization: Bearer $TOKEN" "$WORKSPACE_URL/api/2.1/unity-catalog/storage-credentials/connector_cred" | grep -q '"name"'; then
  #           echo "üóëÔ∏è Deleting existing credential 'connector_cred' with force=true"
  #           curl -X DELETE \
  #             -H "Authorization: Bearer $TOKEN" \
  #             "$WORKSPACE_URL/api/2.1/unity-catalog/storage-credentials/connector_cred?force=true"
  #           sleep 5
  #         else
  #           echo "‚úÖ No existing credential found"
  #         fi

  #     - run : |
  #         terraform apply -auto-approve \
  #           -target=module.databricks.databricks_storage_credential.credential \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üîç Capture Access Connector Info (from terraform outputs)
  #       id: connector-info
  #       run: |
  #         set -euo pipefail
      
  #         ACCESS_CONNECTOR_ID=$(terraform output -raw databricks_access_connector_id 2>/dev/null || true)
  #         PRINCIPAL_ID=$(terraform output -raw databricks_access_connector_principal_id 2>/dev/null || true)
      
  #         if [ -z "$ACCESS_CONNECTOR_ID" ] || [ -z "$PRINCIPAL_ID" ]; then
  #           echo "‚ùå Terraform outputs for access connector are missing. Make sure the connector was applied."
  #           echo "ACCESS_CONNECTOR_ID=$ACCESS_CONNECTOR_ID" >> $GITHUB_ENV
  #           echo "PRINCIPAL_ID=$PRINCIPAL_ID" >> $GITHUB_ENV
  #           exit 1
  #         fi
      
  #         echo "‚úÖ Access Connector ID: $ACCESS_CONNECTOR_ID"
  #         echo "‚úÖ Principal ID: $PRINCIPAL_ID"
      
  #         echo "ACCESS_CONNECTOR_ID=$ACCESS_CONNECTOR_ID" >> $GITHUB_ENV
  #         echo "PRINCIPAL_ID=$PRINCIPAL_ID" >> $GITHUB_ENV
  
  #     - name: üèóÔ∏è Assign Blob Contributor Role to Storage Account (with retries)
  #       run: |
  #         set -euo pipefail
      
  #         STORAGE_ACCOUNT="${{ env.STORAGE_ACCOUNT_NAME }}"
  #         PRINCIPAL_ID="${{ env.PRINCIPAL_ID }}"
  #         SCOPE=$(az storage account show --name "$STORAGE_ACCOUNT" --query id -o tsv)
      
  #         if [ -z "$SCOPE" ]; then
  #           echo "‚ùå Could not find storage account $STORAGE_ACCOUNT"
  #           exit 1
  #         fi
      
  #         for i in 1 2 3 4 5; do
  #           echo "Attempt #$i to assign 'Storage Blob Data Contributor'..."
  #           if az role assignment create --assignee "$PRINCIPAL_ID" --role "Storage Blob Data Contributor" --scope "$SCOPE" >/dev/null 2>&1; then
  #             echo "‚úÖ Role assigned"
  #             break
  #           fi
  #           echo "‚è≥ Role assign failed, sleeping 10s before retry..."
  #           sleep 10
  #         done

  #     - name: üõ†Ô∏è Set ADLS Gen2 ACLs for Databricks Managed Identity (with retries)
  #       run: |
  #         set -euo pipefail
      
  #         ACCOUNT="${{ env.STORAGE_ACCOUNT_NAME }}"
  #         PRINCIPAL="${{ env.PRINCIPAL_ID }}"
      
  #         for container in bronze silver gold; do
  #           echo "üîë Setting ACL on $container"
  #           for i in 1 2 3 4; do
  #             if az storage fs access set \
  #                  --account-name "$ACCOUNT" \
  #                  --file-system "$container" \
  #                  --path / \
  #                  --acl "user:${PRINCIPAL}:rwx" \
  #                  >/dev/null 2>&1; then
  #               echo "‚úÖ ACL set on $container"
  #               break
  #             fi
  #             echo "ACL failed for $container. Retry #$i in 10s..."
  #             sleep 10
  #           done
  #         done

  #     - name: üöÄ Create Databricks External Locations
  #       run: |
  #         terraform apply -auto-approve \
  #           -target=module.databricks.databricks_external_location.bronze \
  #           -target=module.databricks.databricks_external_location.silver \
  #           -target=module.databricks.databricks_external_location.gold \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üöÄ Create Databricks Schema
  #       run: |   
  #         terraform apply -auto-approve \
  #           -target=module.databricks.databricks_schema.data_processing_db \
  #           -var="subscription_id=$(az account show --query id -o tsv)"
        
  #     - name: üöÄ Create Databricks Job
  #       run: |
  #         terraform apply -auto-approve \
  #           -refresh=false \
  #           -target=module.databricks.databricks_job.data_process \
  #           -var="client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" \
  #           -var="client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" \
  #           -var="tenant_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" \
  #           -var="subscription_id=$(az account show --query id -o tsv)" \
  #           -var="git_repo_branch=${{ github.ref_name }}" \
  #           -var="git_repo_url=https://github.com/${{ github.repository }}.git" \
  #           -var="enable_databricks=true"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  # access:
  #   name: üîë Assign Roles
  #   runs-on: ubuntu-latest
  #   needs: databricks
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
  
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure
  
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
  
  #     - run: terraform init
  
  #     - run: |
  #         terraform plan -out=tfplan -no-color \
  #           -target=module.access.azurerm_role_assignment.raw_access \
  #           -target=module.access.azurerm_role_assignment.bronze_access \
  #           -target=module.access.azurerm_role_assignment.silver_access \
  #           -target=module.access.azurerm_role_assignment.gold_access \
  #           -var="subscription_id=$(az account show --query id -o tsv)"
  #         terraform show -no-color tfplan >> plan.txt
  
  #     - run: terraform validate
  
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.access.azurerm_role_assignment.raw_access \
  #           -target=module.access.azurerm_role_assignment.bronze_access \
  #           -target=module.access.azurerm_role_assignment.silver_access \
  #           -target=module.access.azurerm_role_assignment.gold_access \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  # databricks-groups:
  #   name: üë• Create Databricks Groups
  #   runs-on: ubuntu-latest
  #   needs: databricks
  #   env:
  #     WORKSPACE_URL: ${{ needs.databricks.outputs.workspace_url }}
  #     TOKEN: ${{ needs.databricks.outputs.token }}
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure

  #     - name: üîé Ensure Databricks Workspace Info
  #       run: |
  #         if [ -z "${{ env.WORKSPACE_URL }}" ] || [ -z "${{ env.TOKEN }}" ]; then
  #           echo "Databricks workspace URL or token is missing!"
  #           exit 1
  #         fi

  #     - name: üë• Create data_engineers group
  #       run: |
  #         echo "üì° Creating group data_engineers..."
  #         RESPONSE=$(curl -i -w "\nStatus: %{http_code}\n" -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
  #           -H "Authorization: Bearer $TOKEN" \
  #           -H "Content-Type: application/scim+json" \
  #           -d '{"displayName":"data_engineers"}')
  #         echo "üîç API Response:"
  #         echo "$RESPONSE"
    
  #     - name: üë• Create data_scientists group
  #       run: |
  #         echo "üì° Creating group data_scientists..."
  #         RESPONSE=$(curl -i -w "\nStatus: %{http_code}\n" -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
  #           -H "Authorization: Bearer $TOKEN" \
  #           -H "Content-Type: application/scim+json" \
  #           -d '{"displayName":"data_scientists"}')
  #         echo "üîç API Response:"
  #         echo "$RESPONSE"
    
  #     - name: üë• Create data_analysts group
  #       run: |
  #         echo "üì° Creating group data_analysts..."
  #         RESPONSE=$(curl -i -w "\nStatus: %{http_code}\n" -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
  #           -H "Authorization: Bearer $TOKEN" \
  #           -H "Content-Type: application/scim+json" \
  #           -d '{"displayName":"data_analysts"}')
  #         echo "üîç API Response:"
  #         echo "$RESPONSE"
      
      # - name: üë• Create data_engineers group
      #   run: |
      #     curl -s -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_engineers"}' || echo "Group may already exist"
  
      # - name: üë• Create data_scientists group
      #   run: |
      #     curl -s -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_scientists"}' || echo "Group may already exist"
  
      # - name: üë• Create data_analysts group
      #   run: |
      #     curl -s -X POST "$WORKSPACE_URL/api/2.0/preview/scim/v2/Groups" \
      #       -H "Authorization: Bearer $TOKEN" \
      #       -H "Content-Type: application/scim+json" \
      #       -d '{"displayName":"data_analysts"}' || echo "Group may already exist"

      # - name: üì§ Upload Terraform state
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: terraform-state
      #     path: infrastructure/terraform.tfstate
      #     overwrite: true

  # generate-summary:
  #   name: üìù Generate Creation and Update Summary
  #   runs-on: ubuntu-latest
  #   needs:
  #     - resource-group
  #     # - acr
  #     # - aks
  #     - databricks
  #     - storage-account
  #     - storage-containers
  #     - access
  #     - databricks-groups
  #   steps:
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}
  
  #     - name: üìù Generate Terraform Summary Table
  #       run: |
  #         echo "## üöÄ Terraform Created Resources" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "| Resource Type | Resource Name | Deployment Status |" >> $GITHUB_STEP_SUMMARY
  #         echo "|---------------|---------------|-----------------| " >> $GITHUB_STEP_SUMMARY
  
  #         RG_NAME="${{ needs.resource-group.outputs.RESOURCE_GROUP_NAME }}"
  #         if az group show --name "$RG_NAME" &>/dev/null; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #         echo "| Resource Group | $RG_NAME | $STATUS |" >> $GITHUB_STEP_SUMMARY
  
  #         ACR_NAME="${{ needs.acr.outputs.CONTAINER_REGISTRY_NAME }}"
  #         if az acr show --name "$ACR_NAME" &>/dev/null; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #         echo "| Container Registry | $ACR_NAME | $STATUS |" >> $GITHUB_STEP_SUMMARY
  
  #         AKS_NAME="${{ needs.aks.outputs.KUBERNETES_SERVICE }}"
  #         if az aks show --name "$AKS_NAME" --resource-group "$RG_NAME" &>/dev/null; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #         echo "| Kubernetes Cluster | $AKS_NAME | $STATUS |" >> $GITHUB_STEP_SUMMARY
  
  #         STA_NAME="${{ needs.storage-account.outputs.STORAGE_ACCOUNT_NAME }}"
  #         if az storage account show --name "$STA_NAME" --resource-group "$RG_NAME" &>/dev/null; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #         echo "| Storage Account | $STA_NAME | $STATUS |" >> $GITHUB_STEP_SUMMARY
  
  #         for CONTAINER in raw bronze silver gold; do
  #           if az storage container show --account-name "$STA_NAME" --name "$CONTAINER" &>/dev/null; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #           echo "| Storage Container | $CONTAINER | $STATUS |" >> $GITHUB_STEP_SUMMARY
  #         done
  
  #         DB_WORKSPACE="${{ needs.databricks.outputs.WORKSPACE_URL }}"
  #         if [ -n "$DB_WORKSPACE" ]; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #         echo "| Databricks Workspace | $DB_WORKSPACE | $STATUS |" >> $GITHUB_STEP_SUMMARY
  
  #         for GROUP in data_engineers data_scientists data_analysts; do
  #           RESPONSE=$(curl -s -H "Authorization: Bearer $TOKEN" "$DB_WORKSPACE/api/2.0/preview/scim/v2/Groups")
  #           if echo "$RESPONSE" | grep -q "\"displayName\": \"$GROUP\""; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #           echo "| Databricks Group | $GROUP | $STATUS |" >> $GITHUB_STEP_SUMMARY
  #         done
  
  #         for ROLE in raw_access bronze_access silver_access gold_access; do
  #           # Aqui voc√™ pode fazer checagem via az role assignment list
  #           if az role assignment list --assignee "${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}" --query "[?roleDefinitionName=='$ROLE']" -o tsv | grep -q .; then STATUS="‚úÖ"; else STATUS="‚ùå"; fi
  #           echo "| Role Assignment | $ROLE | $STATUS |" >> $GITHUB_STEP_SUMMARY
  #         done
