run-name: Deploy Cloud Infrastructure 
name: Deploy Cloud Infrastructure

permissions: write-all

on:
  workflow_dispatch:

jobs:
  check-gh-pat:
    name: üîê Check GH_PAT_TOKEN and permissions
    runs-on: ubuntu-latest
    steps:
      - name: üîé Check if GH_PAT_TOKEN is present
        run: |
          if [ -z "${{ secrets.GH_PAT_TOKEN }}" ]; then
            echo "Error: the GH_PAT_TOKEN secret is not defined in the repository."
            exit 1
          else
            echo "Secret GH_PAT_TOKEN found."
          fi

      - name: üîó Test token permission via API (checks if it can access the current repository)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          echo "Testing API access with GH_PAT_TOKEN..."
          HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/$REPO)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: GH_PAT_TOKEN does not have permission to access the repository $REPO."
            echo "API response:"
            cat response.json
            exit 1
          else
            echo "Valid token with access to the repository."
          fi

      - name: üß™ Test if token can access secrets API
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          echo "Checking if the token can access the secrets API..."
          HTTP_CODE=$(curl -s -o secrets_response.json -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/$REPO/actions/secrets)
  
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: the GH_PAT_TOKEN token does not have permission to access the secrets API in the repository $REPO."
            echo "API response:"
            cat secrets_response.json
            exit 1
          else
            echo "Token has access to the secrets API. It can probably create secrets as well."
          fi

  check-azure-role-assignments:
    name: üìú Check Azure Role Assignments
    runs-on: ubuntu-latest
    steps:
      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üîé Check Role Assignments
        run: |
          set -e

          CLIENT_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
          SUBSCRIPTION_ID="${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}"
          SCOPE="/subscriptions/$SUBSCRIPTION_ID"

          echo "üîç Checking permissions for Service Principal: $CLIENT_ID in scope $SCOPE..."

          ROLES=$(az role assignment list --assignee "$CLIENT_ID" --scope "$SCOPE" --query "[].roleDefinitionName" -o tsv)

          echo "$ROLES" | grep -q "Contributor" || {
            echo "‚ùå Service Principal does not have the 'Contributor' role"
            exit 1
          }

          echo "$ROLES" | grep -q "User Access Administrator" || {
            echo "‚ùå Service Principal does not have the 'User Access Administrator' role"
            exit 1
          }

          echo "‚úÖ Client ID has the 'Contributor' and 'User Access Administrator' roles."
          
  resource-group:
    name: üèóÔ∏è Creating Resource Group
    runs-on: ubuntu-latest
    needs: [check-azure-role-assignments, check-gh-pat]
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3

      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üìÅ Check and set RUN_ID
        id: check-run-id
        run: |
          RUN_ID_PATH="../assets/terraform_state/run_id.txt"
      
          if [ ! -f "$RUN_ID_PATH" ]; then
            echo "‚úÖ run_id.txt file not found. Download step will be skipped."
            echo "SKIP_DOWNLOAD=true" >> "$GITHUB_ENV"
            exit 0
          fi
      
          if [ ! -s "$RUN_ID_PATH" ]; then
            echo "‚ö†Ô∏è run_id.txt file is empty. Download step will be skipped."
            echo "SKIP_DOWNLOAD=true" >> "$GITHUB_ENV"
            exit 0
          fi
      
          RUN_ID=$(cat "$RUN_ID_PATH")
          echo "RUN_ID=$RUN_ID" >> "$GITHUB_ENV"
          echo "SKIP_DOWNLOAD=false" >> "$GITHUB_ENV"
      
      - name: üì• Download Terraform state
        if: env.SKIP_DOWNLOAD == 'false'
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure
          run-id: ${{ env.RUN_ID }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: üß∞ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - run: terraform init

      - run: |
           terraform plan -out=tfplan -no-color \
           -target=module.resource_group.azurerm_resource_group.rg \
           -var="subscription_id=$(az account show --query id -o tsv)"
           terraform show -no-color tfplan >> plan.txt
      - uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure/plan.txt
          overwrite: true
      
      - run: terraform validate
      
      - run: | 
          terraform apply -auto-approve \
            -target=module.resource_group.azurerm_resource_group.rg \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: üì§ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: üì§ Upload Terraform summary
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: infrastructure/plan.txt
          overwrite: true

      - name: üíæ Save current run ID
        run: echo "${{ github.run_id }}" > ../assets/terraform_state/run_id.txt
      
      - name: üí¨ Commit run ID
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git add ../assets/terraform_state/run_id.txt
          git commit -m "Terraform State run_id"
          git push --force-with-lease

      - name: üì¶ Get Resource Group Name
        id: tfoutput_rg
        run: |
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP_NAME" >> $GITHUB_ENV

      - name: üßæ Set RESOURCE_GROUP_NAME secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          RESOURCE_GROUP_NAME: ${{ env.RESOURCE_GROUP_NAME }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set RESOURCE_GROUP --repo $REPO --body "$RESOURCE_GROUP_NAME"

  # acr:
  #   name: üê≥ Creating Container Registry (ACR)
  #   runs-on: ubuntu-latest
  #   needs: resource-group
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}

  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure

  #     - name: üì• Download Terraform summary
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.acr.azurerm_container_registry.acr \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true

  #     - run: terraform validate
  
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.acr.azurerm_container_registry.acr \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: üì¶ Get Container Registry Name
  #       id: tfoutput_acr
  #       run: |
  #         CONTAINER_REGISTRY_NAME=$(terraform output -raw container_registry_name)
  #         echo "CONTAINER_REGISTRY_NAME=$CONTAINER_REGISTRY_NAME" >> $GITHUB_ENV

  #     - name: üßæ Set CONTAINER_REGISTRY_NAME secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         CONTAINER_REGISTRY_NAME: ${{ env.CONTAINER_REGISTRY_NAME }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set ACR_NAME --repo $REPO --body "$CONTAINER_REGISTRY_NAME"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: üì§ Upload Terraform summary
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: infrastructure/plan.txt
  #         overwrite: true
          
  # aks:
  #   name: ‚ò∏Ô∏è Creating AKS Cluster
  #   runs-on: ubuntu-latest
  #   needs: [resource-group, acr]
  #   defaults:
  #     run:
  #       working-directory: ./infrastructure
  #   steps:
  #     - uses: actions/checkout@v3
      
  #     - name: üîê Azure Login
  #       uses: azure/login@v1
  #       with:
  #         creds: ${{ secrets.AZURE_CREDENTIALS }}
      
  #     - name: üì• Download Terraform state
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: ./infrastructure

  #     - name: üì• Download Terraform summary
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure
      
  #     - name: üß∞ Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_version: 1.5.7
      
  #     - run: terraform init

  #     - run: |
  #          terraform plan -out=tfplan -no-color \
  #          -target=module.aks.azurerm_kubernetes_cluster.aks \
  #          -var="subscription_id=$(az account show --query id -o tsv)"
  #          terraform show -no-color tfplan >> plan.txt
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: ./infrastructure/plan.txt
  #         overwrite: true
  
  #     - run: terraform validate
  
  #     - run: |
  #         terraform apply -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -target=module.aks.azurerm_kubernetes_cluster.aks \
  #           -target=module.aks.azurerm_role_assignment.aks_acr_pull \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #         terraform destroy -auto-approve \
  #           -target=module.aks.azurerm_network_watcher.default \
  #           -var="subscription_id=$(az account show --query id -o tsv)"

  #     - name: ‚òÅÔ∏è Get Azure Kubernetes Service Name
  #       id: tfoutput_aks
  #       run: |
  #         KUBERNETES_SERVICE=$(terraform output -raw kubernetes_cluster_name)
  #         echo "KUBERNETES_SERVICE=$KUBERNETES_SERVICE" >> $GITHUB_ENV

  #     - name: üßæ Set KUBERNETES_SERVICE secret via gh CLI
  #       env:
  #         GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
  #         KUBERNETES_SERVICE: ${{ env.KUBERNETES_SERVICE }}
  #         REPO: ${{ github.repository }}
  #       run: |
  #         gh secret set AKS_NAME --repo $REPO --body "$KUBERNETES_SERVICE"

  #     - name: üì§ Upload Terraform state
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/terraform.tfstate
  #         overwrite: true

  #     - name: üì§ Upload Terraform summary
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: terraform-plan-txt
  #         path: infrastructure/plan.txt
  #         overwrite: true

  debug:
    runs-on: ubuntu-latest
    steps:
      - name: üîé Get workspace URL and AAD token
        id: get-databricks-info
        run: |
          tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
          post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=2ff814a6-3304-4ab8-85cb-cd0e6f879c1d/.default"
          TOKEN=$(curl -X POST -H "Content-Type: application/x-www-form-urlencoded" $uri --data "$post_data" | jq -r '.access_token')
          WORKSPACE_URL="https://$(terraform output -raw databricks_workspace_url)"
          echo "WORKSPACE_URL=$WORKSPACE_URL" >> $GITHUB_ENV
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$TOKEN"
  
      - name: üîß Create Git Credential on Databricks
        run: |
          curl -X POST "$WORKSPACE_URL/api/2.0/git-credentials" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "git_provider": "gitHub",
              "git_username": "x-token-auth",
              "personal_access_token": "'"${{ secrets.GH_PAT_TOKEN }}"'"
            }'

      - name: üîç Check and Rename Databricks Catalogs
        shell: bash
        run: |
          echo "üîç Checking Databricks catalogs..."
          catalogs=$(curl -s -X GET -H "Authorization: $TOKEN" "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs")
      
          echo "üìÑ Full API response:"
          echo "$catalogs"
      
          catalog_count=$(echo "$catalogs" | jq '.catalogs | length // 0')
          if [[ "$catalog_count" -eq 0 ]]; then
              echo "‚ö†Ô∏è No catalogs found or API returned invalid data"
              exit 0
          fi
      
          echo "üìÇ Catalogs encontrados:"
          echo "$catalogs" | jq '.catalogs[]'
      
          echo "$catalogs" | jq -r '.catalogs[].name' > catalogs.txt
      
          while read -r name; do
            echo "‚ÑπÔ∏è Verificando cat√°logo: $name"
            if [[ "$name" == *dbw* ]]; then
              new_name="data_catalog"
              echo "üß† Tentando renomear $name ‚Üí $new_name"
      
              response=$(curl -s -w "\n%{http_code}" -X PATCH \
                -H "Authorization: $TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"new_name\": \"$new_name\"}" \
                "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs/$name")
      
              body=$(echo "$response" | head -n1)
              status=$(echo "$response" | tail -n1)
      
              echo "üì§ Response body: $body"
              echo "üìä HTTP status: $status"
      
              if [[ "$status" -ge 200 && "$status" -lt 300 ]]; then
                echo "‚úÖ Catalog renamed successfully."
              else
                echo "‚ö†Ô∏è Failed to rename catalog $name, skipping."
              fi
            else
              echo "‚ÑπÔ∏è Catalog $name does not need renaming."
            fi
          done < catalogs.txt
  
  storage-account:
    name: üíæ Creating Storage Account
    runs-on: ubuntu-latest
    needs: [resource-group]
    # aks]
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üì• Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure

      - name: üì• Download Terraform summary
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure
      
      - name: üß∞ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - run: terraform init

      - run: |
           terraform plan -out=tfplan -no-color \
           -target=module.storage.azurerm_storage_account.lake \
           -target=module.storage.azurerm_role_assignment.spn_storage_blob_contributor \
           -var="subscription_id=$(az account show --query id -o tsv)" \
           -var="client_id=${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"
           terraform show -no-color tfplan >> plan.txt
      
      - uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure/plan.txt
          overwrite: true
      
      - run: terraform validate
      
      - run: |
          terraform apply -auto-approve \
            -target=module.storage.azurerm_storage_account.lake \
            -target=module.storage.azurerm_role_assignment.spn_storage_blob_contributor \
            -var="subscription_id=$(az account show --query id -o tsv)" \
            -var="client_id=${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}"

      - name: üì¶ Get Storage Account Name
        id: tfoutput_storage
        run: |
          STORAGE_ACCOUNT_NAME=$(terraform output -raw storage_account_name)
          echo "STORAGE_ACCOUNT_NAME=$STORAGE_ACCOUNT_NAME" >> $GITHUB_ENV
  
      - name: üßæ Set STORAGE_ACCOUNT secret via gh CLI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          STORAGE_ACCOUNT_NAME: ${{ env.STORAGE_ACCOUNT_NAME }}
          REPO: ${{ github.repository }}
        run: |
          gh secret set STORAGE_ACCOUNT --repo $REPO --body "$STORAGE_ACCOUNT_NAME"

      - name: üì§ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: üì§ Upload Terraform summary
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: infrastructure/plan.txt
          overwrite: true

  storage-containers:
    name: üìÅ Creating Storage Containers
    runs-on: ubuntu-latest
    needs: [resource-group, storage-account]
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üì• Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure

      - name: üì• Download Terraform summary
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure
      
      - name: üß∞ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - run: terraform init

      - run: |
           terraform plan -out=tfplan -no-color \
            -target=module.storage.azurerm_storage_container.raw \
            -target=module.storage.azurerm_storage_container.bronze \
            -target=module.storage.azurerm_storage_container.silver \
            -target=module.storage.azurerm_storage_container.gold \
           -var="subscription_id=$(az account show --query id -o tsv)"
           terraform show -no-color tfplan >> plan.txt
      
      - uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure/plan.txt
          overwrite: true
      
      - run: terraform validate
      
      - run: |
          terraform apply -auto-approve \
            -target=module.storage.azurerm_storage_container.raw \
            -target=module.storage.azurerm_storage_container.bronze \
            -target=module.storage.azurerm_storage_container.silver \
            -target=module.storage.azurerm_storage_container.gold \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: üì§ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: üì§ Upload Terraform summary
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: infrastructure/plan.txt
          overwrite: true
  
  databricks:
    name: üß™ Creating Databricks Workspace
    runs-on: ubuntu-latest
    needs: [resource-group, storage-account, storage-containers]
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - uses: actions/checkout@v3
      
      - name: üîê Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üì• Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure

      - name: üì• Download Terraform summary
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure
      
      - name: üß∞ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
      
      - run: terraform init

      - run: |
           terraform plan -out=tfplan -no-color \
             -target=module.databricks.azurerm_databricks_workspace.dbw \
             -var="subscription_id=$(az account show --query id -o tsv)"
           terraform show -no-color tfplan >> plan.txt
      
      - uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure/plan.txt
          overwrite: true
      
      - run: terraform validate
      
      - run: |
          terraform apply -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -target=module.databricks.azurerm_databricks_workspace.dbw \
            -var="subscription_id=$(az account show --query id -o tsv)" \

          terraform destroy -auto-approve \
            -target=module.aks.azurerm_network_watcher.default \
            -var="subscription_id=$(az account show --query id -o tsv)"

      - name: üîé Get workspace URL and AAD token
        id: get-databricks-info
        run: |
          tenant_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          uri="https://login.microsoftonline.com/$tenant_ID/oauth2/v2.0/token"
          post_data="grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret&scope=2ff814a6-3304-4ab8-85cb-cd0e6f879c1d/.default"
          TOKEN=$(curl -X POST -H "Content-Type: application/x-www-form-urlencoded" $uri --data "$post_data" | jq -r '.access_token')
          WORKSPACE_URL="https://$(terraform output -raw databricks_workspace_url)"
          echo "WORKSPACE_URL=$WORKSPACE_URL" >> $GITHUB_ENV
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$TOKEN"

      - name: üîß Create Git Credential on Databricks
        run: |
          curl -X POST "$WORKSPACE_URL/api/2.0/git-credentials" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "git_provider": "gitHub",
              "git_username": "x-token-auth",
              "personal_access_token": "'"${{ secrets.GH_PAT_TOKEN }}"'"
            }'

      # - name: üß© Normalize Databricks Catalog Name
      #   run: |
      #     echo "üîç Checking Databricks catalogs..."
      #     catalogs=$(curl -s -X GET \
      #       -H "Authorization: Bearer $TOKEN" \
      #       "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs")
      
      #     echo "$catalogs" | jq -r '.catalogs[].name' > catalogs.txt
      
      #     while read -r name; do
      #       if [[ "$name" == *dbw* ]]; then
      #         new_name="data_catalog"
      #         echo "üß† Renaming catalog $name ‚Üí $new_name"
      
      #         curl -s -X PATCH \
      #           -H "Authorization: Bearer $TOKEN" \
      #           -H "Content-Type: application/json" \
      #           -d "{\"new_name\": \"$new_name\"}" \
      #           "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs/$name"
      
      #         echo "‚úÖ Catalog renamed successfully."
      #       else
      #         echo "‚ÑπÔ∏è Catalog $name does not need renaming."
      #       fi
      #     done < catalogs.txt

      - name: üîç Check and rename Databricks catalogs
        shell: bash
        run: |
          echo "üîç Checking Databricks catalogs..."
          catalogs=$(curl -s -X GET \
            -H "Authorization: $TOKEN" \
            "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs")
      
          echo "üìÑ Catalogs retornados pela API:"
          echo "$catalogs" | jq '.catalogs[]'
      
          echo "$catalogs" | jq -r '.catalogs[].name' > catalogs.txt
      
          while read -r name; do
            echo "‚ÑπÔ∏è Verificando cat√°logo: $name"
            if [[ "$name" == *dbw* ]]; then
              new_name="data_catalog"
              echo "üß† Tentando renomear $name ‚Üí $new_name"
      
              response=$(curl -s -w "\n%{http_code}" -X PATCH \
                -H "Authorization: $TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"new_name\": \"$new_name\"}" \
                "$WORKSPACE_URL/api/2.1/unity-catalog/catalogs/$name")
      
              body=$(echo "$response" | head -n1)
              status=$(echo "$response" | tail -n1)
      
              echo "üì§ Response body: $body"
              echo "üìä HTTP status: $status"
      
              if [[ "$status" -ge 200 && "$status" -lt 300 ]]; then
                echo "‚úÖ Catalog renamed successfully."
              else
                echo "‚ö†Ô∏è Failed to rename catalog $name, skipping."
              fi
            else
              echo "‚ÑπÔ∏è Catalog $name does not need renaming."
            fi
          done < catalogs.txt

      - name: üöÄ Handle Databricks Schema Based on Workspace Changes
        shell: bash
        run: |
          terraform show -json tfplan > plan.json
      
          echo "üîé Debug: todas as altera√ß√µes no plan"
          jq -r '.resource_changes[] | "\(.type) \(.name) actions: \(.change.actions[]?)"' plan.json
      
          echo "üîé Debug: altera√ß√µes da workspace dbw"
          jq -r '
            .resource_changes[]
            | select(.type=="azurerm_databricks_workspace" and .name=="dbw")
            | {before: .change.before, after: .change.after, actions: .change.actions}
          ' plan.json
      
          CHANGED_DBW=$(jq -r '
            .resource_changes[]
            | select(.type=="azurerm_databricks_workspace" and .name=="dbw")
            | .change.actions[]?
          ' plan.json)
      
          echo "üîç Debug: a√ß√µes detectadas para workspace dbw: $CHANGED_DBW"
      
          if [ -n "$CHANGED_DBW" ]; then
              echo "üßπ Workspace dbw alterada, removendo schema do state"
              terraform state rm module.databricks.databricks_schema.data_processing_db 2>/dev/null || true
          else
              echo "‚ÑπÔ∏è Workspace dbw n√£o requer remo√ß√£o da schema"
          fi
      
          terraform apply -auto-approve \
            -target=module.databricks.databricks_schema.data_processing_db \
            -var="subscription_id=$(az account show --query id -o tsv)"
      
      # - name: üöÄ Create Databricks Schema
      #   run: |
      #     # if [ "$APPLY_EXIT" = "2" ]; then
      #     #     echo "üßπ Schema will be recreated, removing from state"
      #     #     terraform state rm module.databricks.databricks_schema.data_processing_db 2>/dev/null || true
      #     # else
      #     #     echo "Schema will not be recreated, keeping state"
      #     # fi

      #     if [ "$APPLY_EXIT" = "2" ]; then
      #         terraform show -json tfplan > plan.json
          
      #         REPLACE_DBW=$(jq -r '
      #           .resource_changes[]
      #           | select(.type=="azurerm_databricks_workspace" and .name=="dbw")
      #           | .change.actions[]
      #         ' plan.json | grep -w "replace")
          
      #         if [ -n "$REPLACE_DBW" ]; then
      #             echo "üßπ Workspace will be replaced ‚Üí removing schema from state"
      #             terraform state rm module.databricks.databricks_schema.data_processing_db 2>/dev/null || true
      #         else
      #             echo "Schema will not be recreated, workspace change does not require replace"
      #         fi
      #     else
      #         echo "Schema will not be recreated, no changes detected in workspace"
      #     fi
          
      #     terraform apply -auto-approve \
      #       -target=module.databricks.databricks_schema.data_processing_db \
      #       -var="subscription_id=$(az account show --query id -o tsv)"
        
      - name: üöÄ Create Databricks Job
        run: |
          terraform apply -auto-approve \
            -refresh=false \
            -target=module.databricks.databricks_job.data_process \
            -var="client_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')" \
            -var="client_secret=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')" \
            -var="tenant_id=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')" \
            -var="subscription_id=$(az account show --query id -o tsv)" \
            -var="git_repo_branch=${{ github.ref_name }}" \
            -var="git_repo_url=https://github.com/${{ github.repository }}.git" \
            -var="enable_databricks=true"

      - name: üì§ Upload Terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/terraform.tfstate
          overwrite: true

      - name: üì§ Upload Terraform summary
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-txt
          path: infrastructure/plan.txt
          overwrite: true

  generate-summary:
    name: üìù Generate Creation and Update Summary
    runs-on: ubuntu-latest
    if: always()
    needs:
      - resource-group
      # - acr
      # - aks
      - databricks
      - storage-account
      - storage-containers
    steps:    
      - name: üì• Download Terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: ./infrastructure

      - name: üìÑ Download Terraform plan file
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-txt
          path: ./infrastructure

      - name: üß∞ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
  
      - name: üìä Generate Terraform
        run: |
          echo "## üöÄ Terraform Created Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
  
          RG_NAME=$(terraform output -state=./infrastructure/terraform.tfstate -raw resource_group_name 2>/dev/null || echo "unknown-rg")
          
          grep -n '^\s*# .*will be created' ./infrastructure/plan.txt || echo "No resources to create found"
  
          if grep -q '^\s*# .*will be created' ./infrastructure/plan.txt; then
            echo "| Resource Type | Resource Name | Deployment Status |" >> $GITHUB_STEP_SUMMARY
            echo "|---------------|---------------|-------------------|" >> $GITHUB_STEP_SUMMARY
  
            grep '^\s*# .*will be created' ./infrastructure/plan.txt | while read -r line; do
              full_id=$(echo "$line" | sed -E 's/^\s*# ([^ ]+) will be created/\1/')
              short_id=$(echo "$full_id" | sed -E 's/^module\.([^.]+)\.//')
            
              full_type=$(echo "$short_id" | awk -F'.' '{print $1}')
              block_name=$(echo "$short_id" | awk -F'.' '{print $2}')
              type=${full_type#azurerm_}

              if [ "$type" = "random_id" ] || 
                 [ "$type" = "role_assignment" ] || 
                 [ "$type" = "databricks_job" ]; then
                continue
              fi

              block=$(sed -n "/+ resource \"$full_type\" \"$block_name\" {/,/^}/p" ./infrastructure/plan.txt)

              name=$(echo "$block" \
                | grep '^[ ~+-]*name\s*=' \
                | head -n1 \
                | sed -E 's/^[ ~+-]*name\s*=\s*"(.*)".*/\1/' \
                | sed -E 's/ ->.*//')

              if [ "$type" = "resource_group" ]; then
                name="$RG_NAME"
              fi
            
              echo "| $type | $name | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "_No resources to create._" >> $GITHUB_STEP_SUMMARY
          fi
  
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîÅ Terraform Updated Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
  
          if grep -q '^\s*# .*must be replaced' ./infrastructure/plan.txt; then
            echo "| Resource Type | Resource Name | Deployment Status |" >> $GITHUB_STEP_SUMMARY
            echo "|---------------|---------------|-------------------|" >> $GITHUB_STEP_SUMMARY
          
            grep '^\s*# .*must be replaced' ./infrastructure/plan.txt | while read -r line; do
              resource=$(echo "$line" | sed -E 's/^\s*# ([^ ]+)\.([^ ]+) must be replaced/\1 \2/')
          
              short_id=$(echo "$resource" | sed -E 's/^module\.([^.]+)\.//')
          
              full_type=$(echo "$short_id" | awk '{print $1}')
              id=$(echo "$short_id" | awk '{print $2}')
              type=${full_type#azurerm_}

              if [ "$type" = "random_id" ] || 
                 [ "$type" = "role_assignment" ] || 
                 [ "$type" = "databricks_job" ]; then
                continue
              fi

              block=$(sed -n "/[-+\/] resource \"$full_type\" \"$id\" {/,/^}/p" ./infrastructure/plan.txt)
          
              if [ -z "$block" ]; then
                echo "‚ö†Ô∏è WARNING: Could not extract block for $full_type.$id"
                continue
              fi

              changed_line=$(echo "$block" | grep -m1 -P '^\s*~ .* = ".*" -> ".*"')
              if [ -n "$changed_line" ]; then
                new_name=$(echo "$changed_line" | sed -E 's/.*-> "(.*)".*/\1/')
              else
                new_name=$(echo "$block" | grep '^[ +-]*name\s*=' | head -n1 | sed -E 's/^[ +-]*name\s*=\s*"(.*)"/\1/')
              fi
          
              if [ -z "$new_name" ]; then
                new_name="$id"
              fi

               if [ "$type" = "resource_group" ]; then
                new_name="$RG_NAME"
              fi
          
              echo "| $type | $new_name | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "_No resources to update._" >> $GITHUB_STEP_SUMMARY
          fi
